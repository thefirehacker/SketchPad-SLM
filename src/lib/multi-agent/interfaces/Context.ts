/**
 * Research Context
 * 
 * The shared context that flows through all agents in the pipeline.
 * Each agent enriches this context with its findings.
 */

import { SourceReference } from '@/components/DeepResearch/components/ResearchSteps';

export interface ChunkData {
  id: string;
  text: string;
  source: string;
  similarity?: number;
  metadata?: Record<string, any>;
  // Enhanced for multi-document support
  sourceDocument?: string; // Which document this chunk comes from
  sourceType?: 'rag' | 'web' | 'uploaded' | 'document'; // Type of source
  documentIndex?: number; // Index when multiple documents
}

export interface Understanding {
  intent: string;
  domain: string;
  requirements: string[];
  queryType: string; // 'ranking', 'comparison', 'information', etc.
}

export interface DocumentAnalysis {
  documentType: string; // 'CV', 'Research Paper', 'Manual', 'Blog', etc.
  structure: string[]; // Key sections/components
  contentAreas: string[]; // Specific information types
  queryIntent: string; // What user wants from this document type
  extractionStrategy: string; // How to approach extraction
  expectedOutputFormat: string; // Format for final answer
  // Enhanced for multi-document support
  documents?: SingleDocumentAnalysis[]; // Analysis for each document separately
  relationships?: DocumentRelationship[]; // How documents relate to each other
  crossDocumentStrategy?: string; // How to combine information across documents
}

export interface SingleDocumentAnalysis {
  documentId: string;
  documentName: string;
  documentType: string;
  primaryEntity?: string; // Main person/company/subject in this document
  structure: string[];
  contentAreas: string[];
  keyEntities: EntityReference[]; // People, companies, projects mentioned
  role: 'source' | 'target' | 'reference'; // Role in answering the query
}

export interface EntityReference {
  name: string;
  type: 'person' | 'company' | 'project' | 'technology' | 'achievement';
  context: string; // How this entity appears in the document
  isOwner: boolean; // True if this entity owns/created the content
}

export interface DocumentRelationship {
  type: 'tutorial' | 'comparison' | 'reference' | 'example';
  sourceDoc: string;
  targetDoc: string;
  description: string; // How they relate (e.g., "Person A's methods for Person B to learn")
}

export interface Pattern {
  description: string;
  examples: string[];
  extractionStrategy: string;
  confidence: number;
  regexPattern?: string; // Dynamic regex pattern generated by LLM
}

export interface ExtractedItem {
  content: string;
  value?: any;
  unit?: string;
  context: string;
  confidence: number;
  sourceChunkId: string;
  metadata?: Record<string, any>;
  // Enhanced for multi-document source attribution
  sourceDocument?: string; // Which document this item comes from
  entityOwner?: string; // Which person/entity this fact belongs to
  factType?: 'achievement' | 'skill' | 'experience' | 'method' | 'result'; // Type of fact
  attribution?: string; // Clear attribution text (e.g., "Person A's achievement", "Person B's skill")
}

export interface Synthesis {
  answer: string;
  confidence: number;
  reasoning: string;
  structure: 'list' | 'paragraph' | 'table' | 'structured';
}

export interface ResearchContext {
  // Original user query
  query: string;
  
  // Current understanding of the query
  understanding: Understanding;
  
  // Intelligent document analysis
  documentAnalysis?: DocumentAnalysis;
  
  // RAG search results
  ragResults: {
    chunks: ChunkData[];
    summary: string;
  };
  
  // Discovered patterns in the data
  patterns: Pattern[];
  
  // Extracted information
  extractedData: {
    raw: ExtractedItem[];
    structured: any[];
  };
  
  // Final synthesized answer
  synthesis: Synthesis;
  
  // Agent communications and reasoning trace
  messages: AgentMessage[];
  
  // Shared knowledge base for agent communication
  sharedKnowledge: {
    documentInsights: Record<string, any>; // DataInspector insights
    extractionStrategies: Record<string, any>; // PatternGenerator strategies
    discoveredPatterns: Record<string, any>; // Patterns discovered during processing
    agentFindings: Record<string, any>; // Key findings from each agent
    executionPlan?: any; // PlanningAgent execution plan
  };
  
  // Timing and performance
  metadata: {
    startTime: number;
    agentsInvolved: string[];
    totalChunksProcessed: number;
    searchApproach: 'claude_code_style' | 'traditional_rag';
    chunksFromStorage: number; // How many chunks came from RxDB vs generated
  };
  
  // New properties for multi-synthesis agents
  analyzedData?: {
    cleaned: ExtractedItem[];
    categorized: any[];
    insights: string;
  };
  
  reportSections?: {
    executive: string;
    findings: string;
    details: string;
  };
  
  citations?: {
    sources: string[];
    attributions: string[];
  };
  
  summary?: {
    executive: string;
    keyFindings: string[];
  };
}

export interface AgentMessage {
  from: string;
  to: string;
  timestamp: number;
  type: 'info' | 'request' | 'response' | 'error';
  content: {
    message: string;
    data?: any;
  };
}

/**
 * Create initial context from query and RAG results
 */
export function createInitialContext(
  query: string, 
  ragChunks: SourceReference[]
): ResearchContext {
  return {
    query,
    understanding: {
      intent: '',
      domain: '',
      requirements: [],
      queryType: ''
    },
    ragResults: {
      chunks: ragChunks.map(chunk => ({
        id: chunk.id,
        text: chunk.type === 'document' ? `Document metadata: ${chunk.title}` : (chunk.fullContent || chunk.excerpt || ''), // Document metadata or chunk content
        source: chunk.source,
        similarity: chunk.similarity,
        metadata: chunk.metadata,
        // Enhanced for multi-document support
        sourceDocument: chunk.source,
        sourceType: chunk.type === 'chunk' ? 'rag' : chunk.type === 'web' ? 'web' : chunk.type === 'document' ? 'document' : 'uploaded'
      })),
      summary: ''
    },
    patterns: [],
    extractedData: {
      raw: [],
      structured: []
    },
    synthesis: {
      answer: '',
      confidence: 0,
      reasoning: '',
      structure: 'paragraph'
    },
    messages: [],
    sharedKnowledge: {
      documentInsights: {},
      extractionStrategies: {},
      discoveredPatterns: {},
      agentFindings: {}
    },
    metadata: {
      startTime: Date.now(),
      agentsInvolved: [],
      totalChunksProcessed: ragChunks.length,
      searchApproach: 'claude_code_style',
      chunksFromStorage: ragChunks.length
    }
  };
}